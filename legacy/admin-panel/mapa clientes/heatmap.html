<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Heatmap v2 (filtros)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body { height:100%; margin:0; }
    #map { height:100%; width:100%; }
    .leaflet-container { background: #f8f8f8; }
    .leaflet-interactive { cursor: pointer; } /* cursor "mano" en marcadores */

    /* Barra de control */
    .controlbar {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 1000;
      background: #fff;
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.12);
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      max-width: 92vw;
    }
    .controlbar .row { display:flex; flex-wrap:wrap; align-items:center; gap:8px; }
    .controlbar .stats { color:#333; }
    .controlbar button {
      border: 0;
      border-radius: 6px;
      padding: 8px 10px;
      background: #2b7cff;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    .controlbar label {
      display:inline-flex; align-items:center; gap:6px;
      background:#f3f5f9; padding:6px 8px; border-radius:6px; cursor:pointer;
    }
    .legend { margin-top: 6px; font-size: 12px; color: #555; }
    .dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle; }

    /* Desplegable de filtros */
    details.user-filter { margin-top:8px; }
    details.user-filter summary {
      cursor: pointer; user-select: none;
      list-style: none; display: inline-flex; align-items:center; gap:8px;
      background:#f3f5f9; padding:6px 10px; border-radius: 8px;
    }
    details.user-filter[open] summary { background:#e8eefc; }
    .user-list {
      margin-top:8px; background:#fff; border:1px solid #e5e7eb; border-radius:8px;
      max-height: 240px; overflow:auto; padding:8px;
      box-shadow: 0 8px 24px rgba(0,0,0,.08);
    }
    .user-row { display:flex; align-items:center; gap:8px; padding:4px 2px; }
    .user-row .chip { width:12px; height:12px; border-radius:50%; display:inline-block; flex-shrink:0; }
    .user-row label { display:flex; align-items:center; gap:8px; width:100%; cursor:pointer; }
    .user-row small { color:#6b7280; }
    .user-filter-actions { display:flex; gap:8px; margin-top:8px; }
    .user-filter-actions button {
      background:#e5e7eb; color:#111; padding:6px 8px; border-radius:6px; border:0; cursor:pointer;
    }

    /* La capa de calor no bloquea clics */
    .leaflet-heat-pane { pointer-events: none; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Barra superpuesta -->
  <div class="controlbar">
    <div class="row" style="margin-bottom:6px;">
      <button id="reloadBtn">Actualizar</button>
      <button id="centerBtn" style="background:#16a34a">Centrar</button>
      <label><input type="checkbox" id="toggleHeat" checked> Heatmap</label>
      <label><input type="checkbox" id="toggleMarkers" checked> Marcadores</label>
    </div>

    <div class="stats">
      <span id="statCount">Puntos: 0</span> ·
      <span id="statUsers">Usuarios: 0</span> ·
      <span id="statUpdated">Última actualización: —</span>
    </div>

    <details class="user-filter" id="userFilter">
      <summary>Filtrar usuarios</summary>
      <div class="user-filter-actions">
        <button type="button" id="selectAll">Seleccionar todo</button>
        <button type="button" id="selectNone">Ninguno</button>
      </div>
      <div class="user-list" id="userList"><!-- checkboxes dinámicos --></div>
    </details>

    <div class="legend" id="legendHelp">
      <span class="dot" style="background:#888"></span>Color distinto por usuario. Click en un marcador para ver nombre / socio.
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- Leaflet.heat -->
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <!-- Firebase loader con fallback (gstatic -> jsdelivr) -->
  <script>
    // Expone: window._firebaseReady (Promise) y window.db
    window._firebaseReady = (async () => {
      function load(src) {
        return new Promise((res, rej) => {
          const s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.onload = () => res(true);
          s.onerror = () => rej(new Error('Load fail: ' + src));
          document.head.appendChild(s);
        });
      }

      const APP   = "https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js";
      const STORE = "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js";

      try {
        await load(APP);
        await load(STORE);
      } catch (e) {
        console.warn('[HEATMAP] gstatic bloqueado. Uso CDN fallback.', e);
        await load("https://cdn.jsdelivr.net/npm/firebase@9.22.2/firebase-app-compat.js");
        await load("https://cdn.jsdelivr.net/npm/firebase@9.22.2/firebase-firestore-compat.js");
      }

      // === Firebase: misma config que tu PWA ===
      const firebaseConfig = {
        apiKey: "AIzaSyAvBw_Cc-t8lfip_FtQ1w_w3DrPDYpxINs",
        authDomain: "sistema-fidelizacion.firebaseapp.com",
        projectId: "sistema-fidelizacion",
        storageBucket: "sistema-fidelizacion.appspot.com",
        messagingSenderId: "357176214962",
        appId: "1:357176214962:web:6c1df9b74ff0f3779490ab"
      };

      if (!firebase.apps?.length) firebase.initializeApp(firebaseConfig);
      window.db = firebase.firestore(); // lo dejamos global
    })();
  </script>

  <script>
    console.log('HEATMAP v2 cargado');

    // === Inicializar mapa ===
    const map = L.map('map', { worldCopyJump: true, preferCanvas: true, zoomControl: true })
      .setView([-34.6037, -58.3816], 11);

    // Panes
    map.createPane('heatPane');
    map.getPane('heatPane').style.zIndex = 350;
    map.getPane('heatPane').style.pointerEvents = 'none';

    map.createPane('markersPane');
    map.getPane('markersPane').style.zIndex = 650;

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contrib.'
    }).addTo(map);

    // Layers
    let heatLayer = null;
    let markersLayer = L.layerGroup([], { pane: 'markersPane' }).addTo(map);

    // UI refs
    const reloadBtn     = document.getElementById('reloadBtn');
    const centerBtn     = document.getElementById('centerBtn');
    const toggleHeat    = document.getElementById('toggleHeat');
    const toggleMarkers = document.getElementById('toggleMarkers');
    const statCount  = document.getElementById('statCount');
    const statUsers  = document.getElementById('statUsers');
    const statUpd    = document.getElementById('statUpdated');
    const userListEl = document.getElementById('userList');
    const selectAll  = document.getElementById('selectAll');
    const selectNone = document.getElementById('selectNone');

    // Selección de usuarios actuales
    const selectedUids = new Set();

    // Utiles
    function hashCode(str){ let h=0; for(let i=0;i<str.length;i++){ h=((h<<5)-h)+str.charCodeAt(i); h|=0; } return Math.abs(h); }
    function colorForUid(uid){ const h = hashCode(uid||'anon') % 360; return `hsl(${h} 85% 45%)`; }

    // Anti-solape: jitter estable por UID (~10–14 m). SOLO marcadores (heat usa coord real)
    function offsetByUid(uid, lat, lng) {
      const radiusM = 10 + (hashCode(uid) % 5);
      const angle   = (hashCode(uid) % 360) * Math.PI / 180;
      const dLat = (radiusM / 111111) * Math.sin(angle);
      const dLng = (radiusM / (111111 * Math.cos((lat * Math.PI)/180))) * Math.cos(angle);
      return [lat + dLat, lng + dLng];
    }

    // Parseo doc -> punto
    function parsePointFromDoc(id, d){
      const lat =
        (typeof d.lat3 === 'number' && d.lat3) ??
        (typeof d.lat  === 'number' && d.lat)  ??
        (d.centerRounded && typeof d.centerRounded.lat3 === 'number' && d.centerRounded.lat3);
      const lng =
        (typeof d.lng3 === 'number' && d.lng3) ??
        (typeof d.lng  === 'number' && d.lng)  ??
        (d.centerRounded && typeof d.centerRounded.lng3 === 'number' && d.centerRounded.lng3);
      if (typeof lat !== 'number' || typeof lng !== 'number') return null;

      const uid = d.uid || id;

      const rawName  = (d.nombre ?? d.name ?? d.displayName ?? d.display ?? '').toString().trim();
      const socioVal = (d.numeroSocio ?? d.nroSocio ?? d.socio);
      const socio    = (socioVal !== undefined && socioVal !== null) ? String(socioVal).trim() : '';

      let display;
      if (rawName && socio) display = `${rawName} — Socio ${socio}`;
      else if (rawName)     display = rawName;
      else if (socio)       display = `Socio ${socio}`;
      else                  display = id ? `UID ${String(id).slice(0,6)}` : '(sin nombre)';

      const when = d.capturedAt || d.updatedAt || null;

      return { lat, lng, uid, name: rawName, socio, displayName: display, when };
    }

    function fitToPoints(pts){
      if (!pts || !pts.length) return;
      if (pts.length === 1){ map.setView([pts[0].lat, pts[0].lng], Math.max(13, map.getZoom())); return; }
      const bounds = L.latLngBounds(pts.map(p => [p.lat, p.lng]));
      if (bounds.isValid()) map.fitBounds(bounds.pad(0.15));
    }

    // Registro para UI/filtrado
    const registry = {
      markers: new Map(),   // uid -> marker
      meta:    new Map(),   // uid -> { uid, name, socio, displayName }
      heat:    []           // { uid, lat, lng, i }
    };

    function refreshLayersVisibility() {
      // Marcadores
      registry.markers.forEach((marker, uid) => {
        if (selectedUids.has(uid) && toggleMarkers.checked) {
          if (!markersLayer.hasLayer(marker)) markersLayer.addLayer(marker);
        } else {
          if (markersLayer.hasLayer(marker)) markersLayer.removeLayer(marker);
        }
      });

      // Heat
      if (heatLayer) {
        const latlngs = registry.heat
          .filter(p => selectedUids.has(p.uid) && toggleHeat.checked)
          .map(p => [p.lat, p.lng, p.i]);
        heatLayer.setLatLngs(latlngs);

        const userCount = Array.from(registry.meta.keys()).filter(uid => selectedUids.has(uid)).length;
        statCount.textContent = `Puntos: ${latlngs.length}`;
        statUsers.textContent = `Usuarios: ${userCount}`;
      } else {
        const userCount = Array.from(registry.meta.keys()).filter(uid => selectedUids.has(uid)).length;
        statUsers.textContent = `Usuarios: ${userCount}`;
      }
    }

    function buildUserFilterList() {
      const items = Array.from(registry.meta.values())
        .sort((a,b) => (a.displayName || '').localeCompare(b.displayName || ''));

      userListEl.innerHTML = items.map(meta => {
        const color = colorForUid(meta.uid);
        const labelText = meta.displayName || meta.name || `UID ${meta.uid.slice(0,6)}`;
        return `
          <div class="user-row">
            <input type="checkbox" class="uf-check" data-uid="${meta.uid}" id="uf_${meta.uid}" checked>
            <label for="uf_${meta.uid}">
              <span class="chip" style="background:${color}"></span>
              <span>${labelText}</span>
              <small>&nbsp;(${meta.uid.slice(0,6)})</small>
            </label>
          </div>
        `;
      }).join('');

      // Selección inicial = todos
      selectedUids.clear();
      registry.meta.forEach((_, uid) => selectedUids.add(uid));

      // Listeners
      userListEl.onchange = (e) => {
        const cb = e.target.closest('.uf-check');
        if (!cb) return;
        const uid = cb.dataset.uid;
        if (cb.checked) selectedUids.add(uid); else selectedUids.delete(uid);
        refreshLayersVisibility();
      };
      selectAll.onclick = () => {
        userListEl.querySelectorAll('.uf-check').forEach(cb => cb.checked = true);
        selectedUids.clear(); registry.meta.forEach((_, uid) => selectedUids.add(uid));
        refreshLayersVisibility();
      };
      selectNone.onclick = () => {
        userListEl.querySelectorAll('.uf-check').forEach(cb => cb.checked = false);
        selectedUids.clear(); refreshLayersVisibility();
      };
    }

    let _reloadTimer = null;
    function scheduleReload(delay=0){ clearTimeout(_reloadTimer); _reloadTimer = setTimeout(loadAndRender, delay); }

    async function loadAndRender(){
      let snap;
      try {
        snap = await db.collection('public_heatmap')
          .orderBy('capturedAt', 'desc')
          .limit(2000)
          .get();
      } catch(e){
        console.error('[HEATMAP] Error leyendo public_heatmap:', e);
        alert('No se pudo leer public_heatmap. Revisá reglas Firestore.');
        return;
      }

      // Reset
      registry.markers.clear(); registry.meta.clear(); registry.heat = [];
      markersLayer.clearLayers();
      if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; }

      const pts = []; const users = new Set(); let latestTs = 0;

      snap.forEach(doc => {
        const p = parsePointFromDoc(doc.id, doc.data());
        if (!p) return;
        pts.push(p); users.add(p.uid);
        const t = p.when ? Date.parse(p.when) : 0; if (t && t>latestTs) latestTs = t;

        registry.meta.set(p.uid, { uid: p.uid, name: p.name, socio: p.socio, displayName: p.displayName });
        registry.heat.push({ uid: p.uid, lat: p.lat, lng: p.lng, i: 0.9 });

        const [latJ, lngJ] = offsetByUid(p.uid, p.lat, p.lng);
        const marker = L.circleMarker([latJ, lngJ], {
          pane: 'markersPane', radius: 6, weight: 1,
          color: '#1f2937', fillColor: colorForUid(p.uid), fillOpacity: 0.92
        }).bindPopup(`
          <div style="font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;">
            <div style="font-weight:700; margin-bottom:4px;">${p.displayName}</div>
            <div><b>UID:</b> ${p.uid}</div>
            <div><b>Lat/Lng:</b> ${p.lat.toFixed(3)}, ${p.lng.toFixed(3)} (≈110m)</div>
            ${p.when ? `<div><b>Actualizado:</b> ${new Date(p.when).toLocaleString()}</div>` : ''}
          </div>
        `);
        registry.markers.set(p.uid, marker);
      });

      // Stats totales
      statCount.textContent = `Puntos: ${pts.length}`;
      statUsers.textContent = `Usuarios: ${users.size}`;
      statUpd.textContent   = `Última actualización: ${latestTs ? new Date(latestTs).toLocaleString() : '—'}`;

      // Añadir capas según toggles
      if (toggleMarkers.checked) { registry.markers.forEach(m => markersLayer.addLayer(m)); }
      if (toggleHeat.checked && registry.heat.length) {
        heatLayer = L.heatLayer(registry.heat.map(p => [p.lat, p.lng, p.i]),
          { pane: 'heatPane', radius: 22, blur: 16, maxZoom: 17 }).addTo(map);
      }

      // Fit y UI
      if (pts.length) fitToPoints(pts);
      buildUserFilterList();
      refreshLayersVisibility();

      console.log('[HEATMAP] puntos:', pts.length, 'uids:', Array.from(registry.meta.keys()));
    }

    // Controles
    reloadBtn.onclick = () => scheduleReload(0);
    centerBtn.onclick = () => {
      const pts = Array.from(registry.heat).map(p => ({lat:p.lat,lng:p.lng}));
      if (pts.length) fitToPoints(pts);
    };
    toggleHeat.onchange = () => {
      if (!heatLayer && toggleHeat.checked) {
        heatLayer = L.heatLayer([], { pane: 'heatPane', radius: 22, blur: 16, maxZoom: 17 }).addTo(map);
      }
      refreshLayersVisibility();
    };
    toggleMarkers.onchange = () => refreshLayersVisibility();

    // Cargar al iniciar CUANDO Firebase esté listo
    window._firebaseReady
      .then(() => { loadAndRender(); })
      .catch(err => {
        console.error('[HEATMAP] Firebase no cargó:', err);
        alert('No se pudo cargar Firebase (bloqueo de red o del navegador).');
      });
  </script>
</body>
</html>
